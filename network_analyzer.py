#!/usr/bin/env python3
"""
Network Analyzer - A simple tool for IP analysis and network scanning

This script provides functionality to:
1. Validate IP addresses
2. Extract basic network information (network address, broadcast, subnet)
3. Perform simple ping sweeps with safety checks
4. Display results in a structured format

IMPORTANT NOTICE:
Only use this tool on networks you have explicit permission to scan.
Unauthorized scanning may violate laws and network policies.

Author: Generated by AI Assistant
Date: 2025-04-22
"""

import ipaddress
import socket
import subprocess
import sys
import os
import argparse
import concurrent.futures
import platform
from datetime import datetime


def validate_ip(ip_str):
    """
    Validate if the provided string is a valid IPv4 address.
    
    Args:
        ip_str (str): The IP address string to validate
        
    Returns:
        bool: True if valid, False otherwise
    """
    try:
        ipaddress.IPv4Address(ip_str)
        return True
    except ValueError:
        return False


def get_network_info(ip_str, cidr=24):
    """
    Extract network information from an IP address and CIDR notation.
    
    Args:
        ip_str (str): The IP address string
        cidr (int): CIDR notation (default: 24)
        
    Returns:
        dict: Network information including network address, broadcast, etc.
    """
    try:
        # Create the network
        network = ipaddress.IPv4Network(f"{ip_str}/{cidr}", strict=False)
        
        # Gather network information
        info = {
            "network_address": str(network.network_address),
            "broadcast_address": str(network.broadcast_address),
            "netmask": str(network.netmask),
            "cidr_notation": str(network),
            "num_addresses": network.num_addresses,
            "hostmin": str(network.network_address + 1),
            "hostmax": str(network.broadcast_address - 1),
            "hosts": list(map(str, list(network.hosts())))[:5] + ['...'] if network.num_addresses > 5 else list(map(str, list(network.hosts())))
        }
        return info
    except Exception as e:
        return {"error": str(e)}


def is_root():
    """
    Check if the script is running with root/administrator privileges.
    
    Returns:
        bool: True if running as root/admin, False otherwise
    """
    if platform.system() == "Windows":
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except:
            return False
    else:
        return os.geteuid() == 0


def ping_host(ip):
    """
    Ping a single host to check if it's up.
    
    Args:
        ip (str): The IP address to ping
        
    Returns:
        tuple: (ip, is_up, response_time or None)
    """
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    command = ['ping', param, '1', '-W', '1', ip]
    
    try:
        start_time = datetime.now()
        result = subprocess.run(
            command, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE,
            text=True,
            timeout=2
        )
        end_time = datetime.now()
        response_time = (end_time - start_time).total_seconds() * 1000  # ms
        
        # Check if ping was successful
        if result.returncode == 0:
            return (ip, True, f"{response_time:.2f}ms")
        else:
            return (ip, False, None)
    except subprocess.TimeoutExpired:
        return (ip, False, None)
    except Exception as e:
        return (ip, False, None)


def ping_sweep(network_address, cidr=24, max_workers=10):
    """
    Perform a ping sweep on a network to discover active hosts.
    
    Args:
        network_address (str): The network address
        cidr (int): CIDR notation (default: 24)
        max_workers (int): Maximum number of concurrent workers (default: 10)
        
    Returns:
        list: List of dictionaries containing results
    """
    # Create network
    network = ipaddress.IPv4Network(f"{network_address}/{cidr}", strict=False)
    
    # Safety check - limit scanning to small networks
    if network.num_addresses > 256:
        print(f"WARNING: Network has {network.num_addresses} addresses. Limiting scan to first 256 hosts.")
        hosts = list(network.hosts())[:256]
    else:
        hosts = list(network.hosts())
    
    results = []
    host_count = len(hosts)
    
    print(f"\nStarting ping sweep of {host_count} hosts in {network}...")
    print("This might take some time depending on the network size.\n")
    
    # Use ThreadPoolExecutor for concurrent pings
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_ip = {executor.submit(ping_host, str(ip)): ip for ip in hosts}
        
        active_hosts = 0
        for i, future in enumerate(concurrent.futures.as_completed(future_to_ip)):
            progress = (i + 1) / host_count * 100
            sys.stdout.write(f"\rProgress: [{i+1}/{host_count}] {progress:.1f}%")
            sys.stdout.flush()
            
            ip, is_up, response_time = future.result()
            if is_up:
                active_hosts += 1
                try:
                    hostname = socket.gethostbyaddr(ip)[0]
                except (socket.herror, socket.gaierror):
                    hostname = "Unknown"
                
                results.append({
                    "ip": ip,
                    "status": "Up",
                    "response_time": response_time,
                    "hostname": hostname
                })
    
    print(f"\n\nScan complete. Found {active_hosts} active hosts out of {host_count} scanned.")
    return results


def print_network_info(info):
    """
    Print network information in a structured format.
    
    Args:
        info (dict): Network information dictionary
    """
    print("\n" + "="*50)
    print("NETWORK INFORMATION")
    print("="*50)
    
    if "error" in info:
        print(f"Error: {info['error']}")
        return
    
    print(f"Network Address:    {info['network_address']}")
    print(f"Broadcast Address:  {info['broadcast_address']}")
    print(f"Netmask:            {info['netmask']}")
    print(f"CIDR Notation:      {info['cidr_notation']}")
    print(f"Number of Addresses: {info['num_addresses']}")
    print(f"Host Range:         {info['hostmin']} - {info['hostmax']}")
    
    if len(info['hosts']) <= 5:
        print(f"Hosts:              {', '.join(info['hosts'])}")
    else:
        print(f"Hosts (first 5):    {', '.join(info['hosts'][:5])} ...")


def print_scan_results(results):
    """
    Print scan results in a structured table format.
    
    Args:
        results (list): List of dictionaries containing scan results
    """
    if not results:
        print("\nNo active hosts found.")
        return
    
    print("\n" + "="*80)
    print("ACTIVE HOSTS")
    print("="*80)
    print(f"{'IP Address':<16} {'Status':<6} {'Response Time':<15} {'Hostname':<40}")
    print("-"*80)
    
    for host in sorted(results, key=lambda x: tuple(map(int, x['ip'].split('.')))):
        print(f"{host['ip']:<16} {host['status']:<6} {host['response_time']:<15} {host['hostname']:<40}")


def check_permissions_warning():
    """
    Display warnings about permissions and ethical considerations.
    
    Returns:
        bool: True if user acknowledges the warning
    """
    if not is_root():
        print("\nWARNING: Some network scanning features may require root/administrator privileges.")
        print("Running with limited capabilities.")
    
    print("\n" + "!"*80)
    print("! IMPORTANT: ONLY SCAN NETWORKS YOU HAVE EXPLICIT PERMISSION TO SCAN")
    print("! Unauthorized scanning may violate laws and network policies.")
    print("!"*80)
    
    response = input("\nDo you confirm that you have permission to scan the specified network? (y/n): ")
    return response.lower() in ('y', 'yes')


def main():
    """
    Main function to run the network analyzer tool.
    """
    parser = argparse.ArgumentParser(description="Network Analyzer Tool")
    parser.add_argument("ip", help="IP address to analyze")
    parser.add_argument("-c", "--cidr", type=int, default=24, help="CIDR notation (default: 24)")
    parser.add_argument("-s", "--scan", action="store_true", help="Perform ping sweep")
    parser.add_argument("-w", "--workers", type=int, default=10, help="Max workers for concurrent scanning (default: 10)")
    
    args = parser.parse_args()
    
    # Validate the IP address
    if not validate_ip(args.ip):
        print(f"Error: '{args.ip}' is not a valid IPv4 address.")
        sys.exit(1)
    
    # Get network information
    info = get_network_info(args.ip, args.cidr)
    print_network_info(info)
    
    # Perform ping sweep if requested
    if args.scan:
        if not check_permissions_warning():
            print("Scan aborted by user.")
            sys.exit(1)
            
        results = ping_sweep(info['network_address'], args.cidr, args.workers)
        print_scan_results(results)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(0)
    except Exception as e:
        print(f"\nAn error occurred: {str(e)}")
        sys.exit(1)

